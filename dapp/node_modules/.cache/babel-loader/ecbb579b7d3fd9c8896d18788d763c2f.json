{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @file coder.js\n * @author Marek Kotewicz <marek@ethdev.com>\n * @date 2015\n */\nvar f = require('./formatters');\n\nvar SolidityTypeAddress = require('./address');\n\nvar SolidityTypeBool = require('./bool');\n\nvar SolidityTypeInt = require('./int');\n\nvar SolidityTypeUInt = require('./uint');\n\nvar SolidityTypeDynamicBytes = require('./dynamicbytes');\n\nvar SolidityTypeString = require('./string');\n\nvar SolidityTypeReal = require('./real');\n\nvar SolidityTypeUReal = require('./ureal');\n\nvar SolidityTypeBytes = require('./bytes');\n\nvar isDynamic = function isDynamic(solidityType, type) {\n  return solidityType.isDynamicType(type) || solidityType.isDynamicArray(type);\n};\n/**\n * SolidityCoder prototype should be used to encode/decode solidity params of any type\n */\n\n\nvar SolidityCoder = function SolidityCoder(types) {\n  this._types = types;\n};\n/**\n * This method should be used to transform type to SolidityType\n *\n * @method _requireType\n * @param {String} type\n * @returns {SolidityType}\n * @throws {Error} throws if no matching type is found\n */\n\n\nSolidityCoder.prototype._requireType = function (type) {\n  var solidityType = this._types.filter(function (t) {\n    return t.isType(type);\n  })[0];\n\n  if (!solidityType) {\n    throw Error('invalid solidity type!: ' + type);\n  }\n\n  return solidityType;\n};\n/**\n * Should be used to encode plain param\n *\n * @method encodeParam\n * @param {String} type\n * @param {Object} plain param\n * @return {String} encoded plain param\n */\n\n\nSolidityCoder.prototype.encodeParam = function (type, param) {\n  return this.encodeParams([type], [param]);\n};\n/**\n * Should be used to encode list of params\n *\n * @method encodeParams\n * @param {Array} types\n * @param {Array} params\n * @return {String} encoded list of params\n */\n\n\nSolidityCoder.prototype.encodeParams = function (types, params) {\n  var solidityTypes = this.getSolidityTypes(types);\n  var encodeds = solidityTypes.map(function (solidityType, index) {\n    return solidityType.encode(params[index], types[index]);\n  });\n  var dynamicOffset = solidityTypes.reduce(function (acc, solidityType, index) {\n    var staticPartLength = solidityType.staticPartLength(types[index]);\n    var roundedStaticPartLength = Math.floor((staticPartLength + 31) / 32) * 32;\n    return acc + (isDynamic(solidityTypes[index], types[index]) ? 32 : roundedStaticPartLength);\n  }, 0);\n  var result = this.encodeMultiWithOffset(types, solidityTypes, encodeds, dynamicOffset);\n  return result;\n};\n\nSolidityCoder.prototype.encodeMultiWithOffset = function (types, solidityTypes, encodeds, dynamicOffset) {\n  var result = \"\";\n  var self = this;\n  types.forEach(function (type, i) {\n    if (isDynamic(solidityTypes[i], types[i])) {\n      result += f.formatInputInt(dynamicOffset).encode();\n      var e = self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);\n      dynamicOffset += e.length / 2;\n    } else {\n      // don't add length to dynamicOffset. it's already counted\n      result += self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);\n    } // TODO: figure out nested arrays\n\n  });\n  types.forEach(function (type, i) {\n    if (isDynamic(solidityTypes[i], types[i])) {\n      var e = self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);\n      dynamicOffset += e.length / 2;\n      result += e;\n    }\n  });\n  return result;\n}; // TODO: refactor whole encoding!\n\n\nSolidityCoder.prototype.encodeWithOffset = function (type, solidityType, encoded, offset) {\n  var self = this;\n\n  if (solidityType.isDynamicArray(type)) {\n    return function () {\n      // offset was already set\n      var nestedName = solidityType.nestedName(type);\n      var nestedStaticPartLength = solidityType.staticPartLength(nestedName);\n      var result = encoded[0];\n\n      (function () {\n        var previousLength = 2; // in int\n\n        if (solidityType.isDynamicArray(nestedName)) {\n          for (var i = 1; i < encoded.length; i++) {\n            previousLength += +encoded[i - 1][0] || 0;\n            result += f.formatInputInt(offset + i * nestedStaticPartLength + previousLength * 32).encode();\n          }\n        }\n      })(); // first element is length, skip it\n\n\n      (function () {\n        for (var i = 0; i < encoded.length - 1; i++) {\n          var additionalOffset = result / 2;\n          result += self.encodeWithOffset(nestedName, solidityType, encoded[i + 1], offset + additionalOffset);\n        }\n      })();\n\n      return result;\n    }();\n  } else if (solidityType.isStaticArray(type)) {\n    return function () {\n      var nestedName = solidityType.nestedName(type);\n      var nestedStaticPartLength = solidityType.staticPartLength(nestedName);\n      var result = \"\";\n\n      if (solidityType.isDynamicArray(nestedName)) {\n        (function () {\n          var previousLength = 0; // in int\n\n          for (var i = 0; i < encoded.length; i++) {\n            // calculate length of previous item\n            previousLength += +(encoded[i - 1] || [])[0] || 0;\n            result += f.formatInputInt(offset + i * nestedStaticPartLength + previousLength * 32).encode();\n          }\n        })();\n      }\n\n      (function () {\n        for (var i = 0; i < encoded.length; i++) {\n          var additionalOffset = result / 2;\n          result += self.encodeWithOffset(nestedName, solidityType, encoded[i], offset + additionalOffset);\n        }\n      })();\n\n      return result;\n    }();\n  }\n\n  return encoded;\n};\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParam\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */\n\n\nSolidityCoder.prototype.decodeParam = function (type, bytes) {\n  return this.decodeParams([type], bytes)[0];\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParam\n * @param {Array} types\n * @param {String} bytes\n * @return {Array} array of plain params\n */\n\n\nSolidityCoder.prototype.decodeParams = function (types, bytes) {\n  var solidityTypes = this.getSolidityTypes(types);\n  var offsets = this.getOffsets(types, solidityTypes);\n  return solidityTypes.map(function (solidityType, index) {\n    return solidityType.decode(bytes, offsets[index], types[index], index);\n  });\n};\n\nSolidityCoder.prototype.getOffsets = function (types, solidityTypes) {\n  var lengths = solidityTypes.map(function (solidityType, index) {\n    return solidityType.staticPartLength(types[index]);\n  });\n\n  for (var i = 1; i < lengths.length; i++) {\n    // sum with length of previous element\n    lengths[i] += lengths[i - 1];\n  }\n\n  return lengths.map(function (length, index) {\n    // remove the current length, so the length is sum of previous elements\n    var staticPartLength = solidityTypes[index].staticPartLength(types[index]);\n    return length - staticPartLength;\n  });\n};\n\nSolidityCoder.prototype.getSolidityTypes = function (types) {\n  var self = this;\n  return types.map(function (type) {\n    return self._requireType(type);\n  });\n};\n\nvar coder = new SolidityCoder([new SolidityTypeAddress(), new SolidityTypeBool(), new SolidityTypeInt(), new SolidityTypeUInt(), new SolidityTypeDynamicBytes(), new SolidityTypeBytes(), new SolidityTypeString(), new SolidityTypeReal(), new SolidityTypeUReal()]);\nmodule.exports = coder;","map":null,"metadata":{},"sourceType":"script"}